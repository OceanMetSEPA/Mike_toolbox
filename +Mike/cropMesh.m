function [op, cells2Keep] = cropMesh(meshStruct, cells2Keep)
% Crop struct containing mesh information, updating cellNeighbours if present.
%
% INPUTS:
%   meshStruct   - struct containing xMesh, yMesh, meshIndices, cellNeighbours, etc.
%   cells2Keep   - logical cell mask, polyshape, or numeric axis
%
% OUTPUT:
%   op          - cropped meshStruct
%   cells2Keep  - logical cell mask

%% --- Determine cells2Keep mask ---
if islogical(cells2Keep)

    if length(cells2Keep) == size(meshStruct.meshIndices,1)
        % Already per-cell mask → OK

    elseif length(cells2Keep) == size(meshStruct.xMesh,1)
        % Mask was per-vertex → convert to per-cell
        k = find(cells2Keep);
        cells2Keep = any(ismember(meshStruct.meshIndices, k), 2);

    else
        error('Logical mask length must match cell count OR node count.');
    end

else
    % --- polygon / axis input ---
    if isa(cells2Keep, 'polyshape')
        [xb, yb] = polyshape2polygon(cells2Keep);

    elseif isa(cells2Keep, 'double')
        try
            [xb, yb] = axis2polygon(cells2Keep);
        catch err
            disp(err)
            error('Numeric input must be axis bounds.');
        end

    else
        error('Invalid cells2Keep input.');
    end

    meshIndices = meshStruct.meshIndices;
    xv = meshStruct.xMesh(meshIndices);
    yv = meshStruct.yMesh(meshIndices);

    % Cell kept if ANY vertex lies inside selection
    cells2Keep = any(inpolygon(xv, yv, xb, yb), 2);
end

%% --- If nothing kept, return empty ---
if ~any(cells2Keep)
    op = [];
    return;
end

%% --- Renumber triangles ---
trik = meshStruct.meshIndices(cells2Keep, :);
[ind, ~, nind] = unique(trik(:));        % unique old nodes
ntrik = reshape(nind, size(trik));       % new triangle index set

% Node mask
Nv = numel(meshStruct.xMesh);
points2Keep = false(1, Nv);
points2Keep(ind) = true;

%% --- Build cropped struct using your structFilter ---
op = structFilter(meshStruct, cells2Keep);     % filter cell-based fields
op = structFilter(op, points2Keep);            % filter node-based fields

op.meshIndices = ntrik;

%% --- Boundary ---
[bd, xbd, ybd] = meshBoundary(op);
op.boundaryIndices  = bd;
op.xMeshBoundary    = xbd;
op.yMeshBoundary    = ybd;

%% --- Mapping from cropped cell index → original cell index ---
op.originalIndices = find(cells2Keep);

%% --- Construct polyshape for cropped mesh ---
% Only take vertices of cropped cells
xv = meshStruct.xMesh(meshStruct.meshIndices);
yv = meshStruct.yMesh(meshStruct.meshIndices);

NTri = sum(cells2Keep);
nans = nan(NTri,1);

xvCrop = [xv(cells2Keep,:), nans]';
yvCrop = [yv(cells2Keep,:), nans]';

xvCrop = xvCrop(:);
yvCrop = yvCrop(:);

op.meshPolyshape = polyshape(xvCrop, yvCrop, 'simplify', 0);

%% ====================================================================
%               UPDATE cellNeighbours  (NUMERIC ARRAY VERSION)
% Note - this generated by findCellNeighbours function
% =====================================================================
if isfield(meshStruct, 'cellNeighbours')

    oldN = meshStruct.cellNeighbours;    % numeric array (nCells × k)
    keepIdx = op.originalIndices;        % old cell indices kept
    nNewCells = numel(keepIdx);

    % Map: old cell index → new cropped cell index
    nOld = size(meshStruct.meshIndices, 1);
    oldToNew = zeros(nOld,1);
    oldToNew(keepIdx) = 1:nNewCells;

    % New neighbour array, same width as oldN
    k = size(oldN,2);
    newN = zeros(nNewCells, k);     % zero padding preserved

    for newID = 1:nNewCells
        oldID = keepIdx(newID);

        % Row of neighbours (0 = no neighbour)
        oldList = oldN(oldID, :);

        % Remove zeros
        oldListNZ = oldList(oldList > 0);

        % Remove neighbours that were not kept
        oldListNZ = oldListNZ(oldToNew(oldListNZ) ~= 0);

        % Convert to new index space
        newList = oldToNew(oldListNZ);

        % Write into new padded row
        m = numel(newList);
        if m > 0
            newN(newID,1:m) = newList(:)';
        end
    end
    op.cellNeighbours = newN;
end

end
